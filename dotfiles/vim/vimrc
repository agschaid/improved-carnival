
let mapleader = ','
let maplocalleader = ','

" always move in wrapped lines
noremap <silent> k gk
noremap <silent> j gj

imap <A-f> (╯°□°)╯︵ ┻━┻
imap <A-s> ¯\_(ツ)_/¯
imap <A-d> (⌐■_■)
imap <A-y> ┌П┐(ಠ_ಠ)
imap <A-l> L(° O °L)

" navigation in split windows
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l
" close
nnoremap <C-c> <C-w>q

" incremental search
set incsearch

" nicer earch colors -> just reverse. Always works
:hi Search cterm=reverse

" incremental search and replace
set inccommand=split
nmap <leader><leader>r :%s//\0/g<Left><Left><Left><Left><Left>a<BS>
xmap <leader><leader>r y:%s/<C-R>"/\0/g<Left><Left>a<BS>

" move current line (or marked lines?) to notNow.txt
:command! -bang -range NotNow <line1>,<line2>write<bang> >> ~/todo/notNow.txt | <line1>,<line2>delete _
" move current line (or marked lines?) to todo.txt
:command! -bang -range Now <line1>,<line2>write<bang> >> ~/todo/todo.txt | <line1>,<line2>delete _

" clear search highlight (and also update the highlight of Minimap)
nmap <leader><leader><leader> :noh<CR>:call minimap#vim#ClearColorSearch()<CR>

" buffers are hidden and not unloaded  -> switch between buffers without save
set hidden

" Don't write backups. Some language servers have issues with backup files, see coc #649.
set nobackup
set nowritebackup

" Give more space for displaying messages -> not anymore (value was 2)
set cmdheight=1

" easier copy
vnoremap <leader>c "+y<CR>


set ignorecase
set smartcase
set number
set background=light
set mouse=a

set tabstop=4
set shiftwidth=4
set expandtab

" make comments look pretty with Victor Mono -> italic in Victor Mono is
" pseudo-handwritten
highlight Comment cterm=italic gui=italic

" show tabs and trailing whitespace. Use some less pronounced solarized color
set list
set listchars=tab:▸\ ,trail:·
:hi BadWhitespace ctermfg=240 " Solarized Base01
:match BadWhitespace / \+$/
:2match BadWhitespace /\t/

" fix quickfix for ghci(d)
set errorformat=%f:(%l\\,%c)-(%e\\,%k):\ %t%*[^:]:%m,%f:%l:%c-%k:\ %t%*[^:]:%m,%f:%l:%c:\ %t%*[^:]:%m

"""""""
" Oh dear. In my haskell project they use subscripts for acronyms. Kind-of-ok.
" But it's a pain in the a$$

"alphsubs ---------------------- {{{
execute "digraphs as " . 0x2090
execute "digraphs es " . 0x2091
execute "digraphs ks " . 0x2096 
execute "digraphs hs " . 0x2095
execute "digraphs is " . 0x1D62
execute "digraphs ks " . 0x2096
execute "digraphs ls " . 0x2097
execute "digraphs ms " . 0x2098
execute "digraphs ns " . 0x2099
execute "digraphs os " . 0x2092
execute "digraphs ps " . 0x209A
execute "digraphs rs " . 0x1D63
execute "digraphs ss " . 0x209B
execute "digraphs ts " . 0x209C
execute "digraphs us " . 0x1D64
execute "digraphs vs " . 0x1D65
execute "digraphs xs " . 0x2093

execute "digraphs As " . 0x1D00
"execute "digraphs Bs " . 0x1D
execute "digraphs Cs " . 0x1D04
execute "digraphs Ds " . 0x1D05
execute "digraphs Es " . 0x1D07
"execute "digraphs Gs " . 0x1D
"execute "digraphs Hs " . 0x1D
"execute "digraphs Is " . 0x1D
execute "digraphs Js " . 0x1D0A
execute "digraphs Ks " . 0x1D0B
"execute "digraphs Ls " . 0x1D
execute "digraphs Ms " . 0x1D0D
"execute "digraphs Ns " . 0x1D
execute "digraphs Os " . 0x1D0F
execute "digraphs Ps " . 0x1D18
"execute "digraphs Rs " . 0x1D
execute "digraphs Ts " . 0x1D1B
execute "digraphs Us " . 0x1D1C
execute "digraphs Vs " . 0x2C20
execute "digraphs Ws " . 0x1D21
execute "digraphs Zs " . 0x1D22

"}}}

"alphtops ---------------------- {{{
execute "digraphs aS " . 0x1d43
execute "digraphs bS " . 0x1d47
execute "digraphs cS " . 0x1d9c
execute "digraphs dS " . 0x1d48
execute "digraphs eS " . 0x1d49
execute "digraphs fS " . 0x1da0
execute "digraphs gS " . 0x1d4d
execute "digraphs hS " . 0x02b0
execute "digraphs iS " . 0x2071
execute "digraphs jS " . 0x02b2
execute "digraphs kS " . 0x1d4f
execute "digraphs lS " . 0x02e1
execute "digraphs mS " . 0x1d50
execute "digraphs nS " . 0x207f
execute "digraphs oS " . 0x1d52
execute "digraphs pS " . 0x1d56
execute "digraphs rS " . 0x02b3
execute "digraphs sS " . 0x02e2
execute "digraphs tS " . 0x1d57
execute "digraphs uS " . 0x1d58
execute "digraphs vS " . 0x1d5b
execute "digraphs wS " . 0x02b7
execute "digraphs xS " . 0x02e3
execute "digraphs yS " . 0x02b8
execute "digraphs zS " . 0x1dbb

execute "digraphs AS " . 0x1D2C
execute "digraphs BS " . 0x1D2E
execute "digraphs DS " . 0x1D30
execute "digraphs ES " . 0x1D31
execute "digraphs GS " . 0x1D33
execute "digraphs HS " . 0x1D34
execute "digraphs IS " . 0x1D35
execute "digraphs JS " . 0x1D36
execute "digraphs KS " . 0x1D37
execute "digraphs LS " . 0x1D38
execute "digraphs MS " . 0x1D39
execute "digraphs NS " . 0x1D3A
execute "digraphs OS " . 0x1D3C
execute "digraphs PS " . 0x1D3E
execute "digraphs RS " . 0x1D3F
execute "digraphs TS " . 0x1D40
execute "digraphs US " . 0x1D41
execute "digraphs VS " . 0x2C7D
execute "digraphs WS " . 0x1D42
"}}}

""" VALUES FOR SOLARIZED BRIGHT
" let g:limelight_conceal_ctermfg = 245  " Solarized Base1
" let g:limelight_conceal_guifg = '#8a8a8a'  " Solarized Base1

""" VALUES FOR SOLARIZED DARK
let g:limelight_conceal_ctermfg = 240  " Solarized Base01
let g:limelight_conceal_guifg = '#585858'  " Solarized Base01

" nnoremap <silent> MM :call LanguageClient_contextMenu()<CR>
" nnoremap <silent> K :call LanguageClient#textDocument_hover()<CR>
" nnoremap <silent> gd :call LanguageClient#textDocument_definition()<CR>

" NERDTREE CONFIG
" Not quite sure why this needs the 'function!' which (if I understand
" correctly) replaces a previous function definition . . . but there is no
" prefious definition.
function! BetterNerdTreeToggle()
    if &filetype == 'nerdtree' || exists("g:NERDTree") && g:NERDTree.IsOpen()
        :NERDTreeToggle
    elseif filereadable(expand('%'))
        NERDTreeFind
    else
        :NERDTree
    endif
endfunction
nnoremap <silent>TT :call BetterNerdTreeToggle()<CR>

" show dot files by default
let NERDTreeShowHidden=1
:hi Directory ctermfg=4  " fix directory coloring of NerdTree

""""""""
" GOYO "
""""""""
" by default start in programming linebreak width
let g:goyo_width = 120

" GOYO QUIT: START
" taken from https://github.com/junegunn/goyo.vim/wiki/Customization
" When Goyo is open :q usually just quits Goyo. Not vim. The code below changes this behavior.
function! s:goyo_enter()
  let b:quitting = 0
  let b:quitting_bang = 0
  autocmd QuitPre <buffer> let b:quitting = 1
  cabbrev <buffer> q! let b:quitting_bang = 1 <bar> q!
endfunction
nnoremap <leader><leader>g :Goyo<CR>

function! s:goyo_leave()
  " Quit Vim if this is the only remaining buffer
  if b:quitting && len(filter(range(1, bufnr('$')), 'buflisted(v:val)')) == 1
    if b:quitting_bang
      qa!
    else
      qa
    endif
  endif
endfunction

autocmd! User GoyoEnter call <SID>goyo_enter()
autocmd! User GoyoLeave call <SID>goyo_leave()
" GOYO QUIT: END

" CTRL-P CONFIG
let g:ctrlp_custom_ignore = '\v[\/](target|dist|jdt.ls-java-project)|(\.(swp|ico|git|svn))$'
" disable working path mode and limit ctrl+p to the current working directory
" https://stackoverflow.com/questions/29399349/cant-get-ctrlp-to-set-working-dir-as-root-folder
let g:ctrlp_working_path_mode = ''


"""""""
" FZF "
"""""""

" make :Ag not search in the filename.
command! -bang -nargs=* Ag call fzf#vim#ag(<q-args>, fzf#vim#with_preview({'options': '--delimiter : --nth 4..'}), <bang>0)

""""""""
" TAGS "
""""""""

" open tags with word under cursor -> is now handled by Telescope
"nmap <leader><leader>t :Tags <c-r><c-a><CR>
nmap gd <c-]><CR>

"""""""""""""
" LIGHTLINE "
"""""""""""""

let g:lightline = {
    \ 'colorscheme': 'solarized',
    \ 'active' : {
    \   'left' : [ ['buffers'] ],
    \   'right' : [[ 'lineinfo' ]]
    \ },
    \ 'component_expand' : {
    \   'buffers': 'lightline#bufferline#buffers'
    \ },
    \ 'component_type': {
    \   'buffers': 'tabsel'
    \ }
    \ }

let g:lightline#bufferline#show_number = 1

" make them clickable
let g:lightline.component_raw = {'buffers': 1}
let g:lightline#bufferline#clickable = 1

" make modified indicator work in buffers
"autocmd BufWritePost,TextChanged,TextChangedI * call lightline#update()

"""""""""""""""""
" YOUCOMPLETEME "
"""""""""""""""""
highlight Pmenu ctermfg=15 ctermbg=0 guifg=#ffffff guibg=#000000

"""""""""""""
" FAST-TAGS "
"""""""""""""
" not really a plugin. But it provides some config for vim
" https://github.com/elaforge/fast-tags/blob/master/tools/vimrc
augroup tags
au BufWritePost *.hs            silent !init-tags %
au BufWritePost *.hsc           silent !init-tags %
augroup END

"""""""""""
" MINIMAP "
"""""""""""
" activate highlight of search
let g:minimap_highlight_search = 1

" start it right away 
" -> no. that sucks in some cases (Goyo/Diary) and kills the simple interface
let g:minimap_auto_start = 0

" enable git support
let g:minimap_git_colors = 1

" toggle mapping
nmap <leader><leader>m :MinimapToggle<CR>

""""""""""""""""
" CURRENT_WORD "
""""""""""""""""
" do NOT highlight the word under the cursor
let g:vim_current_word#highlight_current_word = 0
" don't show highlights right away
let g:vim_current_word#highlight_delay = 350

"""""""""""""
" TELESCOPE "
"""""""""""""
" show buffers
nmap <leader><leader>b :Telescope buffers<CR>
nmap <leader><leader>t :Telescope tags default_text=<c-r><c-a><CR>

"""""""""""""""""""""
" my quickfix stuff "
"""""""""""""""""""""

" taken from https://superuser.com/questions/1124631/vim-auto-reload-quickfix-error-file-when-it-changes

" The filename used for the cfile
let s:cfile_filename = ''
" The last mtime of the filename
let s:cfile_mtime = -1

" Define a command that can be called like:
"
"   Cfile errors.txt
"
command! -nargs=1 -complete=file Cfile call s:Cfile(<f-args>)

function! s:Cfile(filename)
  let s:cfile_filename = a:filename

  " Update every 200ms
  let timer = timer_start(200, function('s:UpdateCfile'), {'repeat': -1})
  " First "update" to actually load the qf window immediately
  call s:UpdateCfile(timer)
endfunction

function! s:UpdateCfile(timer_id)
  " Stop the timer if the file is deleted
  if s:cfile_filename == '' || !filereadable(s:cfile_filename)
    call timer_stop(a:timer_id)
    let s:cfile_filename = ''
    let s:cfile_mtime = -1

    return
  endif

  " Get file mtime
  let mtime = system('stat -c %Y '.shellescape(s:cfile_filename))

  " Load the file in the quickfix window if the mtime is newer than the last
  " recorded one
  if mtime > s:cfile_mtime
    exe 'cfile '.s:cfile_filename
    let s:cfile_mtime = mtime
  endif
endfunction

